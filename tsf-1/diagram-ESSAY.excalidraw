# tsf ESSAY

Can we 10x an engineer? - The Software Factory (tsf) is an approach to this question.

The GOAL is to automate and augment the current SDLC process where we expect to improve productivity:
  - the number of humans in the loop can be reduced for the same work
  - the amount of work created for the same effort is increased

Key challenges
---------------

Trust
Rigour
Repeatability

How do we establish trust if the human is taken out of the loop? How do we trust a computer will both create the code and tell us that the code is correct? What do we do about hallucinations?

TSF approach is to model the roles and processes we have now and automate them.  Applying this process across the software engineering stack is the experient this approach is attempting to prove.

Insights
--------

Software Development is Nonlinear
Consensus in teams is what drives progression
Work is completed by a Role
A council is required to move a piece of work.

## Software Development is Nonlinear

I *thought* that software went from IDEA -> PROCESS -> REALITY.   Zooming in we applied different roles, lifecycles and methods of describing for example with roles:

   IDEA -> Product Manager -> 
   Product Owner -> 
   Business Analyst -> 
   Architect -> 
   Tech Lead -> 
   Engineer -> 
   QA -> 
   Release Manager -> REALITY

That is, the job more-or-less is like a baton, handed on to the next in line.  Obviously this is not true (jobs were handed back and forth) however this was my original mental model.

In fact what happens is everyone talks to everyone - sometimes.  The Engineer clarifies a point wiht the QA who talks to the BA and the release manager coordinates with the Engineering Director or the Product Owner contradicts a prior feature and changes the acceptance criteria on the fly.  Or the engineer has a bad day, writes a bug which slips through because then QA is on vacation.

## Consensus in teams is what drives progression

What happens is some roles get together in a little council and decide to agree or disagree on the outcome of work.  This happens in micro-meetings with some established processes (set ticket status to "in test") - but it also happens adhoc in methods we have not properly captured.

So the progression of any work is as a result of consensus.   Where work proceeds with cosensus of 1 (That is, the engineer says: it works, trust me), is where there is high risk.

## Work is completed by a Role

Any piece of work (ticket, design).  Is carried out by a discretely named ROLE - a Business Analyst.   What happens is the work is then receive by other workers with different motivations - roles - and they will implicitly or explicitly appraise the quality of work, using or rejecting it.  This is as true for a written document as it is for a unit test.

## A council is required to move a piece of work.

We see a ticket goes from OPEN->IN PROGRESS->IN TEST->DONE

In this case we will assemble a COUNCIL to agree that the work is ready for the enxt step.  It is NOT that the work is DONE, is is more that the work of the ROLE is finsihed for now.    

So this means that the outcome of a given piece of work by a given ROLE is just some claimed state - "I'm finished".  But really the proof of work is decided by the recipient - the COUNCIL.

So really work looks like this

ROLE1+WORK -> COMPLETED -> COUNCIL -> OK -> ROLE2+WORK

Until the COUNCIL decides the work is complete.

## Components

<< DIAGRAM >> 

# Terminology

Task
  Discrete piece of work.

Worker
  An running software that uses an LLM

Role
  An agent with motivation (job description and capability)


---

So a TICKET sustem is required to describe and track discrete pieces of work, their progress/history and by whom, their previous an current state.

An ORGANISER role will pick any idle ticket and assemble a COUNCIL to decide what is next.

The COUNCIL is built of ROLEs that have similar but distinct GOALS/OBJECTIVES.
